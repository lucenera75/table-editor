<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Editor Test Suite</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-results {
            margin-top: 20px;
        }
        .test-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #ccc;
        }
        .test-item.passed {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
        .test-item.failed {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        .test-item.running {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .test-summary {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .test-error {
            color: #dc3545;
            font-family: monospace;
            font-size: 12px;
            margin-top: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 20px;
        }
        button:hover {
            background: #0056b3;
        }
        #testArea {
            display: none;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Document Editor Test Suite</h1>
        <button onclick="runAllTests()">Run All Tests</button>

        <div class="test-summary" id="testSummary">
            Click "Run All Tests" to start
        </div>

        <div class="test-results" id="testResults"></div>
    </div>

    <!-- Hidden test area -->
    <div id="testArea"></div>

    <!-- Hidden UI elements required by document-editor.js -->
    <div style="display: none;">
        <div id="textFormatMenu">
            <input type="number" id="textFontSize" value="14">
            <div id="textMenuTextColorDropdown"></div>
            <div id="textMenuBgColorDropdown"></div>
            <div id="textMenuTextColorPreview"></div>
            <div id="textMenuTextColorLabel"></div>
            <div id="textMenuBgColorPreview"></div>
            <div id="textMenuBgColorLabel"></div>
        </div>
        <div id="contextMenu"></div>
        <table id="mainTable"></table>
        <select id="contextAlignSelect"></select>
        <input id="contextFontSizeInput">
        <div id="bgColorPreview"></div>
        <div id="bgColorLabel"></div>
        <div id="textColorPreview"></div>
        <div id="textColorLabel"></div>
    </div>

    <script src="document-editor.js"></script>
    <script>
        let testResults = [];
        let currentTest = null;

        // Test utilities
        function createTestTable(rows, cols) {
            const table = document.createElement('table');
            table.style.borderCollapse = 'collapse';
            table.id = 'mainTable';

            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            for (let c = 0; c < cols; c++) {
                const th = document.createElement('th');
                th.style.border = '1px solid #ddd';
                th.style.padding = '8px';
                th.style.position = 'relative';
                th.setAttribute('onmousedown', 'selectCell(this, event)');
                th.setAttribute('oncontextmenu', 'showContextMenu(event, this)');
                const span = document.createElement('span');
                span.contentEditable = 'false';
                span.textContent = `H${c + 1}`;
                th.appendChild(span);
                headerRow.appendChild(th);
            }
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            for (let r = 0; r < rows - 1; r++) {
                const row = document.createElement('tr');
                for (let c = 0; c < cols; c++) {
                    const td = document.createElement('td');
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '8px';
                    td.style.position = 'relative';
                    td.setAttribute('onmousedown', 'selectCell(this, event)');
                    td.setAttribute('oncontextmenu', 'showContextMenu(event, this)');
                    const span = document.createElement('span');
                    span.contentEditable = 'false';
                    span.textContent = `R${r + 1}C${c + 1}`;
                    td.appendChild(span);
                    row.appendChild(td);
                }
                tbody.appendChild(row);
            }
            table.appendChild(tbody);

            return table;
        }

        function createEditableDiv() {
            const div = document.createElement('div');
            div.contentEditable = 'true';
            div.innerHTML = 'Test text for formatting';
            return div;
        }

        function selectText(element, startOffset, endOffset) {
            const range = document.createRange();
            const textNode = element.firstChild || element;
            range.setStart(textNode, startOffset);
            range.setEnd(textNode, endOffset);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            savedSelection = range.cloneRange();
            return range;
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEquals(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(`${message || 'Assertion failed'}: expected ${expected}, got ${actual}`);
            }
        }

        // Test functions
        async function test_tableCreation() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            assert(table.querySelectorAll('thead tr').length === 1, 'Should have 1 header row');
            assert(table.querySelectorAll('thead th').length === 3, 'Should have 3 header cells');
            assert(table.querySelectorAll('tbody tr').length === 2, 'Should have 2 body rows');
            assert(table.querySelectorAll('tbody td').length === 6, 'Should have 6 body cells');
        }

        async function test_cellSelection() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const cell = table.querySelector('td');
            selectCell(cell);

            assert(selectedCells.length === 1, 'Should have 1 selected cell');
            assert(selectedCells[0] === cell, 'Selected cell should match');
            assert(cell.classList.contains('cell-selected'), 'Cell should have selected class');
        }

        async function test_addRow() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const initialRows = table.querySelectorAll('tbody tr').length;
            const cell = table.querySelector('td');
            selectCell(cell);
            contextMenuTarget = cell;
            addRowBelow();

            assertEquals(table.querySelectorAll('tbody tr').length, initialRows + 1, 'Should have one more row');
        }

        async function test_addColumn() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const initialCols = table.querySelectorAll('thead th').length;
            const cell = table.querySelector('td');
            selectCell(cell);
            contextMenuTarget = cell;
            addColumnRight();

            assertEquals(table.querySelectorAll('thead th').length, initialCols + 1, 'Should have one more column');
        }

        async function test_deleteRow() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(4, 3);
            testArea.appendChild(table);

            const initialRows = table.querySelectorAll('tbody tr').length;
            const cell = table.querySelectorAll('tbody tr')[1].querySelector('td');
            selectCell(cell);
            contextMenuTarget = cell;
            deleteSelectedRow();

            assertEquals(table.querySelectorAll('tbody tr').length, initialRows - 1, 'Should have one less row');
        }

        async function test_deleteColumn() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 4);
            testArea.appendChild(table);

            const initialCols = table.querySelectorAll('thead th').length;
            const cell = table.querySelectorAll('td')[1];
            selectCell(cell);
            contextMenuTarget = cell;
            deleteSelectedColumn();

            assertEquals(table.querySelectorAll('thead th').length, initialCols - 1, 'Should have one less column');
        }

        async function test_mergeCells() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const cells = table.querySelectorAll('tbody tr:first-child td');
            selectedCells = [cells[0], cells[1]];
            cells[0].classList.add('cell-selected');
            cells[1].classList.add('cell-selected');

            mergeSelectedCells();

            assert(cells[0].hasAttribute('colspan'), 'First cell should have colspan');
            assertEquals(cells[0].getAttribute('colspan'), '2', 'Colspan should be 2');
        }

        async function test_textFormatBold() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            selectText(div, 0, 4);
            toggleBold();

            const span = div.querySelector('span');
            assert(span !== null, 'Should create a span');
            assert(span.style.fontWeight === 'bold', 'Span should be bold');
        }

        async function test_textFormatItalic() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            selectText(div, 0, 4);
            toggleItalic();

            const span = div.querySelector('span');
            assert(span !== null, 'Should create a span');
            assert(span.style.fontStyle === 'italic', 'Span should be italic');
        }

        async function test_textFormatUnderline() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            selectText(div, 0, 4);
            toggleUnderline();

            const span = div.querySelector('span');
            assert(span !== null, 'Should create a span');
            assert(span.style.textDecoration.includes('underline'), 'Span should be underlined');
        }

        async function test_textFormatColor() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            selectText(div, 0, 4);
            selectTextMenuTextColor('#ff0000', 'Red');

            const span = div.querySelector('span');
            assert(span !== null, 'Should create a span');
            assert(span.style.color === 'rgb(255, 0, 0)' || span.style.color === '#ff0000', 'Span should be red');
        }

        async function test_textFormatFontSize() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            document.getElementById('textFontSize').value = 20;
            selectText(div, 0, 4);
            applyTextFontSize();

            const span = div.querySelector('span');
            assert(span !== null, 'Should create a span');
            assert(span.style.fontSize === '20px', 'Font size should be 20px');
        }

        async function test_spanReuse() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            // Apply bold first
            selectText(div, 0, 4);
            toggleBold();

            // Apply italic to the same selection
            const span1 = div.querySelector('span');
            selectText(span1, 0, 4);
            toggleItalic();

            const spans = div.querySelectorAll('span');
            assertEquals(spans.length, 1, 'Should reuse the same span');
            assert(span1.style.fontWeight === 'bold', 'Should still be bold');
            assert(span1.style.fontStyle === 'italic', 'Should be italic');
        }

        async function test_toggleHeaders() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const cell = table.querySelector('td');
            contextMenuTarget = cell;

            let thead = table.querySelector('thead');
            assert(thead !== null, 'Should have thead');
            assert(thead.style.display !== 'none', 'Headers should be visible');

            // First toggle - hide headers
            toggleTableHeaders();
            await new Promise(resolve => setTimeout(resolve, 10));
            thead = table.querySelector('thead');
            assertEquals(thead.style.display, 'none', 'Headers should be hidden');

            // Second toggle - show headers
            contextMenuTarget = cell; // Reset target since hideContextMenu clears it
            toggleTableHeaders();
            await new Promise(resolve => setTimeout(resolve, 10));
            thead = table.querySelector('thead');
            assertEquals(thead.style.display, '', 'Headers should be visible again');
        }

        async function test_clearFormat() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const div = createEditableDiv();
            testArea.appendChild(div);

            // Apply multiple formats
            selectText(div, 0, 4);
            toggleBold();

            const span = div.querySelector('span');
            selectText(span, 0, 4);
            toggleItalic();

            assert(span.style.fontWeight === 'bold', 'Should be bold');
            assert(span.style.fontStyle === 'italic', 'Should be italic');

            // Clear format - select the entire span node
            const range = document.createRange();
            range.selectNode(span);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            savedSelection = range.cloneRange();
            clearTextFormat();

            // Check that formatting is removed - the text should be plain (no span with bold/italic)
            await new Promise(resolve => setTimeout(resolve, 10));
            const spans = div.querySelectorAll('span');
            let hasFormatting = false;
            spans.forEach(s => {
                if (s.style.fontWeight === 'bold' || s.style.fontStyle === 'italic') {
                    hasFormatting = true;
                }
            });
            assert(!hasFormatting, 'Bold and italic should be cleared');
        }

        async function test_clearSelectionOnEditableClick() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const div = createEditableDiv();
            testArea.appendChild(div);

            // Select a cell
            const cell = table.querySelector('td');
            selectCell(cell);
            assert(selectedCells.length === 1, 'Should have 1 selected cell');

            // Click on editable div
            const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
            div.dispatchEvent(clickEvent);

            await new Promise(resolve => setTimeout(resolve, 10));
            assertEquals(selectedCells.length, 0, 'Cell selection should be cleared when clicking editable content');
        }

        async function test_multiSelectDrag() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const cells = table.querySelectorAll('td');

            // Simulate drag from first cell to third cell
            const mousedownEvent = new MouseEvent('mousedown', {
                bubbles: true,
                cancelable: true,
                button: 0
            });
            cells[0].dispatchEvent(mousedownEvent);

            // Trigger mouseover on second and third cells
            const mouseoverEvent1 = new MouseEvent('mouseover', { bubbles: true, cancelable: true });
            const mouseoverEvent2 = new MouseEvent('mouseover', { bubbles: true, cancelable: true });
            cells[1].dispatchEvent(mouseoverEvent1);
            cells[2].dispatchEvent(mouseoverEvent2);

            await new Promise(resolve => setTimeout(resolve, 10));

            assert(selectedCells.length >= 2, 'Should have multiple cells selected after drag');
        }

        async function test_multiSelectInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            // Create an editable div
            const div = createEditableDiv();
            testArea.appendChild(div);

            // Set selection in the div and create a table
            const range = document.createRange();
            range.selectNodeContents(div);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            savedSelection = range.cloneRange();

            // Simulate createTableFromMenu by creating a table manually
            const table = document.createElement('table');
            table.style.borderCollapse = 'collapse';

            const tbody = document.createElement('tbody');
            for (let r = 0; r < 2; r++) {
                const row = document.createElement('tr');
                for (let c = 0; c < 3; c++) {
                    const td = document.createElement('td');
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '8px';
                    td.style.position = 'relative';
                    td.onmousedown = function(e) { selectCell(this, e); };

                    const span = document.createElement('span');
                    span.contentEditable = 'true';
                    span.textContent = `Cell ${r}-${c}`;
                    td.appendChild(span);

                    row.appendChild(td);
                }
                tbody.appendChild(row);
            }
            table.appendChild(tbody);
            div.appendChild(table);

            const cells = table.querySelectorAll('td');

            // Test multi-select drag
            const mousedownEvent = new MouseEvent('mousedown', {
                bubbles: true,
                cancelable: true,
                button: 0
            });
            cells[0].dispatchEvent(mousedownEvent);

            const mouseoverEvent1 = new MouseEvent('mouseover', { bubbles: true, cancelable: true });
            const mouseoverEvent2 = new MouseEvent('mouseover', { bubbles: true, cancelable: true });
            cells[1].dispatchEvent(mouseoverEvent1);
            cells[2].dispatchEvent(mouseoverEvent2);

            await new Promise(resolve => setTimeout(resolve, 10));

            assert(selectedCells.length >= 2, 'Should select multiple cells in dynamically created table without error');
        }

        async function test_keyboardNavigationInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            // Create a main table (id=mainTable)
            const mainTable = createTestTable(3, 3);
            testArea.appendChild(mainTable);

            // Create an editable div
            const div = createEditableDiv();
            testArea.appendChild(div);

            // Create a new table (without mainTable id)
            const newTable = document.createElement('table');
            newTable.style.borderCollapse = 'collapse';

            const tbody = document.createElement('tbody');
            for (let r = 0; r < 2; r++) {
                const row = document.createElement('tr');
                for (let c = 0; c < 3; c++) {
                    const td = document.createElement('td');
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '8px';
                    td.style.position = 'relative';
                    td.onmousedown = function(e) { selectCell(this, e); };

                    const span = document.createElement('span');
                    span.contentEditable = 'true';
                    span.textContent = `New${r}-${c}`;
                    td.appendChild(span);

                    row.appendChild(td);
                }
                tbody.appendChild(row);
            }
            newTable.appendChild(tbody);
            div.appendChild(newTable);

            const cells = newTable.querySelectorAll('td');

            // Select first cell in new table
            selectCell(cells[0]);

            // Navigate right with arrow key
            const arrowRightEvent = new KeyboardEvent('keydown', {
                key: 'ArrowRight',
                bubbles: true,
                cancelable: true
            });
            document.dispatchEvent(arrowRightEvent);

            await new Promise(resolve => setTimeout(resolve, 10));

            // Check that navigation stayed in the new table
            assert(currentCell && currentCell.closest('table') === newTable, 'Navigation should stay within the new table');
            assert(currentCell === cells[1], 'Should navigate to the next cell in the new table');
        }

        function createDynamicTable(rows, cols) {
            const table = document.createElement('table');
            table.style.borderCollapse = 'collapse';

            const tbody = document.createElement('tbody');
            for (let r = 0; r < rows; r++) {
                const row = document.createElement('tr');
                for (let c = 0; c < cols; c++) {
                    const td = document.createElement('td');
                    td.style.border = '1px solid #ddd';
                    td.style.padding = '8px';
                    td.style.position = 'relative';
                    td.onmousedown = function(e) { selectCell(this, e); };
                    td.oncontextmenu = function(e) { showContextMenu(e, this); };

                    const span = document.createElement('span');
                    span.contentEditable = 'true';
                    span.textContent = `C${r}-${c}`;
                    td.appendChild(span);

                    row.appendChild(td);
                }
                tbody.appendChild(row);
            }
            table.appendChild(tbody);

            return table;
        }

        async function test_addRowInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const newTable = createDynamicTable(2, 3);
            testArea.appendChild(newTable);

            const initialRows = newTable.querySelectorAll('tbody tr').length;
            const cell = newTable.querySelector('td');
            selectCell(cell);
            contextMenuTarget = cell;
            addRowBelow();

            assertEquals(newTable.querySelectorAll('tbody tr').length, initialRows + 1, 'Should add row in created table');
        }

        async function test_addColumnInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const newTable = createDynamicTable(2, 3);
            testArea.appendChild(newTable);

            const rows = newTable.querySelectorAll('tr');
            const initialCols = rows[0].children.length;
            const cell = newTable.querySelector('td');
            selectCell(cell);
            contextMenuTarget = cell;
            addColumnRight();

            assertEquals(rows[0].children.length, initialCols + 1, 'Should add column in created table');
        }

        async function test_deleteRowInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const newTable = createDynamicTable(3, 3);
            testArea.appendChild(newTable);

            const initialRows = newTable.querySelectorAll('tbody tr').length;
            const cell = newTable.querySelectorAll('tbody tr')[1].querySelector('td');
            selectCell(cell);
            contextMenuTarget = cell;
            deleteSelectedRow();

            assertEquals(newTable.querySelectorAll('tbody tr').length, initialRows - 1, 'Should delete row in created table');
        }

        async function test_deleteColumnInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const newTable = createDynamicTable(3, 4);
            testArea.appendChild(newTable);

            const initialCols = newTable.querySelectorAll('tr')[0].children.length;
            const cell = newTable.querySelectorAll('td')[1];
            selectCell(cell);
            contextMenuTarget = cell;
            deleteSelectedColumn();

            assertEquals(newTable.querySelectorAll('tr')[0].children.length, initialCols - 1, 'Should delete column in created table');
        }

        async function test_mergeCellsInCreatedTable() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const newTable = createDynamicTable(3, 3);
            testArea.appendChild(newTable);

            const cells = newTable.querySelectorAll('tbody tr:first-child td');
            selectedCells = [cells[0], cells[1]];
            cells[0].classList.add('cell-selected');
            cells[1].classList.add('cell-selected');

            mergeSelectedCells();

            assert(cells[0].hasAttribute('colspan'), 'First cell should have colspan in created table');
            assertEquals(cells[0].getAttribute('colspan'), '2', 'Colspan should be 2 in created table');
        }

        async function test_dragSelectionPreservedOnMouseup() {
            const testArea = document.getElementById('testArea');
            testArea.innerHTML = '';

            const table = createTestTable(3, 3);
            testArea.appendChild(table);

            const cells = table.querySelectorAll('td');

            // Simulate drag selection
            const mousedownEvent = new MouseEvent('mousedown', {
                bubbles: true,
                cancelable: true,
                button: 0
            });
            cells[0].dispatchEvent(mousedownEvent);

            const mouseoverEvent = new MouseEvent('mouseover', { bubbles: true, cancelable: true });
            cells[1].dispatchEvent(mouseoverEvent);

            await new Promise(resolve => setTimeout(resolve, 10));

            const selectedCount = selectedCells.length;
            assert(selectedCount >= 2, 'Should have multiple cells selected');

            // Simulate mouseup which triggers click
            const mouseupEvent = new MouseEvent('mouseup', { bubbles: true, cancelable: true });
            cells[1].dispatchEvent(mouseupEvent);

            // Simulate the click that follows mouseup
            const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
            cells[1].dispatchEvent(clickEvent);

            await new Promise(resolve => setTimeout(resolve, 10));

            assertEquals(selectedCells.length, selectedCount, 'Selection should be preserved after mouseup/click');
        }

        // Test runner
        const tests = [
            { name: 'Table Creation', fn: test_tableCreation },
            { name: 'Cell Selection', fn: test_cellSelection },
            { name: 'Add Row', fn: test_addRow },
            { name: 'Add Column', fn: test_addColumn },
            { name: 'Delete Row', fn: test_deleteRow },
            { name: 'Delete Column', fn: test_deleteColumn },
            { name: 'Merge Cells', fn: test_mergeCells },
            { name: 'Text Format: Bold', fn: test_textFormatBold },
            { name: 'Text Format: Italic', fn: test_textFormatItalic },
            { name: 'Text Format: Underline', fn: test_textFormatUnderline },
            { name: 'Text Format: Color', fn: test_textFormatColor },
            { name: 'Text Format: Font Size', fn: test_textFormatFontSize },
            { name: 'Span Reuse', fn: test_spanReuse },
            { name: 'Toggle Headers', fn: test_toggleHeaders },
            { name: 'Clear Format', fn: test_clearFormat },
            { name: 'Clear Selection on Editable Click', fn: test_clearSelectionOnEditableClick },
            { name: 'Multi-Select Drag', fn: test_multiSelectDrag },
            { name: 'Multi-Select in Created Table', fn: test_multiSelectInCreatedTable },
            { name: 'Keyboard Navigation in Created Table', fn: test_keyboardNavigationInCreatedTable },
            { name: 'Add Row in Created Table', fn: test_addRowInCreatedTable },
            { name: 'Add Column in Created Table', fn: test_addColumnInCreatedTable },
            { name: 'Delete Row in Created Table', fn: test_deleteRowInCreatedTable },
            { name: 'Delete Column in Created Table', fn: test_deleteColumnInCreatedTable },
            { name: 'Merge Cells in Created Table', fn: test_mergeCellsInCreatedTable },
            { name: 'Drag Selection Preserved on Mouseup', fn: test_dragSelectionPreservedOnMouseup }
        ];

        async function runAllTests() {
            testResults = [];
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = '';

            let passed = 0;
            let failed = 0;

            for (const test of tests) {
                const testItem = document.createElement('div');
                testItem.className = 'test-item running';
                testItem.textContent = `Running: ${test.name}...`;
                resultsDiv.appendChild(testItem);

                try {
                    await test.fn();
                    testItem.className = 'test-item passed';
                    testItem.textContent = `✓ ${test.name}`;
                    const result = { name: test.name, passed: true };
                    testResults.push(result);
                    console.log('TEST_RESULT:' + JSON.stringify(result));
                    passed++;
                } catch (error) {
                    testItem.className = 'test-item failed';
                    testItem.innerHTML = `✗ ${test.name}<div class="test-error">${error.message}</div>`;
                    const result = { name: test.name, passed: false, error: error.message };
                    testResults.push(result);
                    console.log('TEST_RESULT:' + JSON.stringify(result));
                    failed++;
                }

                // Clean up
                selectedCells = [];
                currentCell = null;
                savedSelection = null;

                await new Promise(resolve => setTimeout(resolve, 10));
            }

            const summary = document.getElementById('testSummary');
            summary.innerHTML = `
                Tests completed: ${passed + failed}<br>
                ✓ Passed: ${passed}<br>
                ✗ Failed: ${failed}
            `;
            summary.style.background = failed === 0 ? '#d4edda' : '#f8d7da';
        }
    </script>
</body>
</html>
